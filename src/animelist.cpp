#include "animelist.h"
#include <stdexcept>
#include <iostream>
//#include "saveload.h"
#include "memory.h"


Animelist::Animelist()
    : m_animeList( std::list<Anime*>() )
{
}


Animelist::Animelist( const std::list<Anime*>& animeList )
{
    copyExternalAnimeList( m_animeList, animeList );
}


Animelist::~Animelist()
{
    Memory::safeDeleteAnimeList( m_animeList );
}


std::list<Anime*> Animelist::getAnimeList() const
{
    if ( m_animeList.empty() )
        return std::list<Anime*>();

    return m_animeList;
}


Animelist& Animelist::operator=( const Animelist& other )
{
    copyExternalAnimeList( m_animeList, other.getAnimeList() );
    return *this;
}


Animelist& Animelist::operator=( const std::list<Anime*>& other )
{
    copyExternalAnimeList( m_animeList, other );
    return *this;
}


void Animelist::copyExternalAnimeList( std::list<Anime*>& toInsert, const std::list<Anime*>& toCopy )
{
    std::list<Anime*>::const_iterator constIt;
    toInsert.clear();

    for ( constIt = toCopy.cbegin(); constIt != toCopy.cend(); ++constIt ) 
    {
        toInsert.push_back( new Anime( **constIt ) ); // first * -> Anime*, second * -> Anime object
    }
}


bool Animelist::isInList( const Anime& a ) const
{
    std::list<Anime*>::const_iterator constIt;
    for ( constIt = m_animeList.cbegin(); constIt != m_animeList.end(); ++constIt )
    {
        if ( ( **constIt ).getName() == a.getName() ) return true; // entry found
    }
    return false;
}



void Animelist::addAnime( Anime* anime )
{
    m_animeList.push_back( anime );
}


void Animelist::sort()
{
    m_animeList.sort( CompareAnimeObjectsBehindPointersAscending );
}


bool Animelist::CompareAnimeObjectsBehindPointersAscending( Anime* const & left, Anime* const & right )
{
    return *left < *right;
}


std::string Animelist::getAnimeNameFromToStringPhrase( const std::string& listItemString )
{
    if ( listItemString.empty() )
    {
        return "";
    }
    size_t bracketPosition = listItemString.find( "(" );
    if ( bracketPosition == std::string::npos )
    {
        throw std::invalid_argument( "error @AnimeList::getAnimeNameFromToStringPhrase(). "
                                     "invalid entry string. string was not generated by Anime::toString()" );
    }
    if ( !listItemString.empty() )
    {
        return listItemString.substr( 0, bracketPosition - 1 );
    }

    return "";
}


Anime* Animelist::getAnimeByName( const std::string& animeName ) const
{
    std::list<Anime*>::const_iterator constIt;
    for ( constIt = m_animeList.cbegin(); constIt != m_animeList.end(); ++constIt )
    {
        if ( (**constIt).getName() == animeName )
            return *constIt; // Anime*
    }

    std::cerr << "Animelist::getAnimeByName(): anime not found: " << animeName << std::endl;
    return nullptr;
}


bool Animelist::deleteAnimeByName( const std::string& animeName )
{
    std::list<Anime*>::iterator it;
    for ( it = m_animeList.begin(); it != m_animeList.end(); ++it )
    {
        if ( (**it).getName() == animeName )
        {
            // anime found
            Memory::safeDelete( *it ); // previously was: delete *it;
            m_animeList.erase( it );
            return true;
        }
    }

    std::cerr << "Animelist::deleteAnimeByName(): anime not found: " << animeName << std::endl;
    return false;
}


void Animelist::popOutByNameWithoutDeletingMemory( const std::string& animeName )
{
    std::list<Anime*>::iterator it;
    for ( it = m_animeList.begin(); it != m_animeList.end(); ++it )
    {
        if ( (**it).getName() == animeName )
        {
            m_animeList.erase( it );
            return;
        }
    }

    std::cerr << "Animelist::deleteAnimeByName(): Could not pop out anime. anime not found: "
              << animeName << std::endl;
}


bool Animelist::isEmpty() const
{
    if ( m_animeList.empty() )
        return true;

    return false;
}


size_t Animelist::size() const
{
    return m_animeList.size();
}


Anime* Animelist::operator[]( unsigned int index ) const
{
    // check out of range
    if ( index >= m_animeList.size() ) throw std::out_of_range( "AnimeList::operator[]: index out of range" );

    // go to position
    std::list<Anime*>::const_iterator it = m_animeList.cbegin();
    for ( unsigned int i = 0; i < index; ++it, i++ ); // traverse through list to position index points to.
                                                      // if index = 7. loop runs 7 times

    return *it;
}


void Animelist::clear()
{
    if ( !m_animeList.empty() ) {
        m_animeList.clear();
    }
}